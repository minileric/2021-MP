import math
import numpy as np

"""

Рассматриваем выражение y′+(2y+1)*ctgx=0, все остальное остается прежним. Да поможет на бог
Решим его как обычный дифур и получим y=(1/2*(sin(x)*C)^2)-1/2
Нам неоткуда взять C, но какое совпадение, переменная С называется так не случайно...)
Будет нашей С

"""


class HalfDivision:
    def __init__(self):                 # инициализируем класс, определяем начальные переменные
        self.A = 8                      # в моей фамилии 8 букв : Б Е С П А Л О В
        self.B = 12                     # и родился я 12 числа
        self.C = 2001 + 11**3           # и в правду в 2001 году, и даже в ноябре, правда не в третьей степени
        self.e = 10**(-12)              # Эпсилон. Точность.

        self.a0 = 0                  # наше начальное приближение
        self.b0 = 1000
        self.sum = 1                    # переменная для будущей работы, в принципе можно было задать в самой функции

    def score(self, x):
        return 1/2*(math.sin(x)*self.C)**2 - 1/2

    def directly_half_division(self):
        """
        Можно, в принципе, использовать конструкцию лямба функции, дабы у нас было уже чуть более функциональное
        программирование, но конструкция по типу s = lambda x: 1/2*(math.sin(x)*self.C)**2 - 1/2 не очень рекомедуется
        офф. руководством. При необходимости заменю, конечно

        """

        summary = 0   # счетчик итераций

        if self.score(self.a0) * self.score(self.b0) >= 0:          # при таком условии корней у нашего ур-я нет :(
            print('No roots here boy,', 'что весьма печально')

        else:
            while self.b0 - self.a0 > self.e:

                self.sum = (self.a0 + self.b0) / 2  # середина отрезка
                if self.score(self.b0) * self.score(self.sum) < 0:       # корень в левом отрезке, сдвигаем грани
                    self.a0 = self.sum  # двигаем левую границу на середину
                else:
                    self.b0 = self.sum  # наоборот

                summary += 1

            print(
                '\n',   # ну хочется мне так, чтобы в общем было красиво на одинаковом отступе
                self.score(self.a0), '- оно же значение в корне' '\n',
                summary, '- количество итераций',  '\n',
                self.sum, ' - корень', '\n',    # можно было и a0 оставить

                  )


work = HalfDivision()                # присваиваем класс используем конструктор

try:
    work.directly_half_division()                   # вызываем нашу функцию ответственную за подсчет
except OverflowError:
    print('Вероятно, переполнение в exp')
